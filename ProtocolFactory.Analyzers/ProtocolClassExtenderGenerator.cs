using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Text;
using System.Threading.Tasks;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using ProtocolFactory.Core.Attributes;
using ProtocolFactory.Core.Contracts;

namespace ProtocolFactory.Analyzers;

[Generator] //unused
public class ProtocolClassExtenderGenerator : IIncrementalGenerator
{

    // Generator'ın başlangıç noktası
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // 1. [Protocol] Özniteliği İle İşaretlenmiş Kısmi Sınıfları Bul
        var protocolClasses = context.SyntaxProvider
            .CreateSyntaxProvider(
                // Predicate: Hızlı filtreleme: Attribute listesi olan Class Declaration'ları seç
                predicate: static (s, _) => s is ClassDeclarationSyntax c && c.AttributeLists.Count > 0,

                // Transform: Anlamsal model ile detaylı analiz yap
                transform: static (ctx, cancellationToken) => GetProtocolClassInfo(ctx)
            )
            // Sadece uygun sınıfları (partial ve [Protocol] ile işaretli) filtrele
            .Where(static info => info is not null)
            .Select(static (info, _) => info!);
        // 2. Kaynak Kodu Üret
        context.RegisterSourceOutput(protocolClasses,
            static (spc, classInfo) => Execute(spc, classInfo));
    }


    private static ClassInfo? GetProtocolClassInfo(GeneratorSyntaxContext context)
    {
        var classDeclaration = (ClassDeclarationSyntax)context.Node;
        var classSymbol = context.SemanticModel.GetDeclaredSymbol(classDeclaration) as INamedTypeSymbol;

        if (classSymbol is null ||
            !classDeclaration.Modifiers.Any(mod => mod.IsKind(SyntaxKind.PartialKeyword)))
        {
            return null;
        }

        // 1. [Protocol] özniteliği kontrolü (Önceki gibi)
        var hasProtocolAttribute = classSymbol.GetAttributes()
            .Any(attr => attr.AttributeClass?.Name == nameof(ProtocolAttribute));

        if (!hasProtocolAttribute)
        {
            return null;
        }

        // 2. İşaretlenmiş Özellikleri Topla
        var fields = new List<PropertyInfo>();

        // Sınıfın tüm üyelerini (members) gez
        foreach (var member in classSymbol.GetMembers().OfType<IPropertySymbol>())
        {
            // Özellikteki [ProtocolField] özniteliğini bul
            var fieldAttribute = member.GetAttributes()
                .FirstOrDefault(attr => attr.AttributeClass?.Name == nameof(ProtocolFieldAttribute));

            if (fieldAttribute is not null)
            {
                // Constructor argümanlarını çöz
                if (fieldAttribute.ConstructorArguments.Length == 3)
                {
                    var startBit = (int)fieldAttribute.ConstructorArguments[0].Value!;
                    var length = (int)fieldAttribute.ConstructorArguments[1].Value!;
                    var endian = fieldAttribute.ConstructorArguments[2].Value!.ToString(); // Endianness Enum değeri

                    fields.Add(new PropertyInfo(
                        Name: member.Name,
                        Type: member.Type.ToDisplayString(), // Property'nin tipi (int, long vb.)
                        StartBit: startBit,
                        Length: length,
                        Endian: endian!
                    ));
                }
            }
        }

        // Hiç özellik bulunmazsa bile sınıfı döndür (IProtocol implementasyonu için)
        return new ClassInfo(
            Name: classSymbol.Name,
            Namespace: classSymbol.ContainingNamespace.ToDisplayString(),
            Accessibility: classSymbol.DeclaredAccessibility.ToString().ToLower(),
            Fields: fields
        );
    }
    private static void Execute(SourceProductionContext context, ClassInfo classInfo)
    {
        var sb = new System.Text.StringBuilder();

        // Güvenilir bir dizinleme için alanları StartBit'e göre sırala
        var orderedFields = classInfo.Fields.OrderBy(f => f.StartBit).ToList();
        var settersCount = orderedFields.Count; // Dizinin boyutu

        // Protokol sınıfının tipi (örneğin MyProtocolClass)
        var protocolClassName = classInfo.Name;

        // Yeni delegate* imzası: delegate*<T, ulong, void>
        var newDelegateSignature = $"delegate*<{protocolClassName}, ulong, void>";

        sb.AppendLine($"// <auto-generated/>");
        sb.AppendLine($"using System.Runtime.CompilerServices;");
        sb.AppendLine($"using System;");
        sb.AppendLine($"using System.Collections.Generic;");
        sb.AppendLine($"using ProtocolFactory.Core.Contracts;");

        sb.AppendLine($"namespace {classInfo.Namespace}");
        sb.AppendLine($"{{");

        // *** DEĞİŞİKLİK 1: Arayüz Uygulaması ***
        // IProtocol<T> generic arayüzünü kendi sınıf tipini kullanarak uyguluyoruz.
        sb.AppendLine($"    {classInfo.Accessibility} partial class {protocolClassName} : IProtocol<{protocolClassName}>");
        sb.AppendLine($"    {{");

        // A. Setters Dizisi Implementasyonu
        // *** DEĞİŞİKLİK 2: Delegate Tipini Güncelleme ***
        sb.AppendLine($"        public unsafe {newDelegateSignature}[] Setters {{ get; }}");
        sb.AppendLine($"            = InitializeSetters();");

        // B. Setter Dizisini Dolduran Metot
        sb.AppendLine($"");
        // *** DEĞİŞİKLİK 3: InitializeSetters Geri Dönüş Tipi Güncelleme ***
        sb.AppendLine($"        private static unsafe {newDelegateSignature}[] InitializeSetters()");
        sb.AppendLine($"        {{");

        sb.AppendLine($"            var setters = new {newDelegateSignature}[{settersCount}];");

        int index = 0;
        foreach (var field in orderedFields)
        {
            // Her özellik için üretilen statik metoda pointer'ı, sırasına göre diziye ekle
            sb.AppendLine($"            setters[{index}] = &Set_{field.Name};");
            index++;
        }

        sb.AppendLine($"            return setters;");
        sb.AppendLine($"        }}");

        // C. Her Özellik İçin Setter Metodu Üretimi (Atama artık mümkün)
        foreach (var field in orderedFields)
        {
            sb.AppendLine($"");
            sb.AppendLine($"        // Generated setter for property: {field.Name} ({field.Type})");
            sb.AppendLine($"        // StartBit: {field.StartBit}, Length: {field.Length}, Endian: {field.Endian}");

            // *** DEĞİŞİKLİK 4: Metot İmzası Güncelleme ***
            // Statik metot, artık ilk parametre olarak sınıf örneğini alıyor.
            sb.AppendLine($"        public static unsafe void Set_{field.Name}({protocolClassName} instance, ulong value)");
            sb.AppendLine($"        {{");

            // Tip Dönüşümü (Cast)
            sb.AppendLine($"            {field.Type} castedValue = ({field.Type})value;");

            // *** DEĞİŞİKLİK 5: Atama Artık Mümkün ***
            // 'instance' parametresi sayesinde özelliğe atama yapabiliriz.
            sb.AppendLine($"");
            sb.AppendLine($"            // Protokol Bit/Endianness manipülasyonu burada olmalı.");
            sb.AppendLine($"            instance.{field.Name} = castedValue;");

            sb.AppendLine($"        }}");
        }

        sb.AppendLine($"    }}");
        sb.AppendLine($"}}");

        context.AddSource($"{classInfo.Name}.ProtocolExtender.g.cs", sb.ToString());
    }

}
// Toplanan sınıf ve özellik listesini tutar (ClassInfo güncelleniyor)
public record ClassInfo(string Name, string Namespace, string Accessibility, List<PropertyInfo> Fields);

// Toplanan özellik bilgisini tutar
public record PropertyInfo(string Name, string Type, int StartBit, int Length, string Endian);


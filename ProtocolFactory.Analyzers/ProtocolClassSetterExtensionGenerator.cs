using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using ProtocolFactory.Analyzers.Calculation;
using ProtocolFactory.Core.Attributes;
using ProtocolFactory.Core.Models;

namespace ProtocolFactory.Analyzers;

[Generator]
public class ProtocolClassSetterExtensionGenerator: IIncrementalGenerator
{
    
    // Generator'ın başlangıç noktası
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // 1. [Protocol] Özniteliği İle İşaretlenmiş Kısmi Sınıfları Bul
        var protocolClasses = context.SyntaxProvider
            .CreateSyntaxProvider(
                // Predicate: Hızlı filtreleme: Attribute listesi olan Class Declaration'ları seç
                predicate: static (s, _) => s is ClassDeclarationSyntax c && c.AttributeLists.Count > 0,

                // Transform: Anlamsal model ile detaylı analiz yap
                transform: static (ctx, cancellationToken) => GetProtocolClassInfo(ctx)
            )
            // Sadece uygun sınıfları (partial ve [Protocol] ile işaretli) filtrele
            .Where(static info => info is not null)
            .Select(static (info, _) => info!);
        // 2. Kaynak Kodu Üret
        context.RegisterSourceOutput(protocolClasses,
            static (spc, classInfo) => Execute(spc, classInfo));
    }


    private static ClassInfo? GetProtocolClassInfo(GeneratorSyntaxContext context)
    {
        var classDeclaration = (ClassDeclarationSyntax)context.Node;
        var classSymbol = ModelExtensions.GetDeclaredSymbol(context.SemanticModel, classDeclaration) as INamedTypeSymbol;

        if (classSymbol is null ||
            !classDeclaration.Modifiers.Any(mod => mod.IsKind(SyntaxKind.PartialKeyword)))
        {
            return null;
        }

        // 1. [Protocol] özniteliği kontrolü (Önceki gibi)
        var hasProtocolAttribute = classSymbol.GetAttributes()
            .Any(attr => attr.AttributeClass?.Name == nameof(ProtocolAttribute));

        if (!hasProtocolAttribute)
        {
            return null;
        }
        
        var fields = new List<PropertyInfo>();
        foreach (var member in classSymbol.GetMembers().OfType<IPropertySymbol>())
        {
            // Özellikteki [ProtocolField] özniteliğini bul
            var fieldAttribute = member.GetAttributes()
                .FirstOrDefault(attr => attr.AttributeClass?.Name == nameof(ProtocolFieldAttribute));

            if (fieldAttribute is not null)
            {
                // Constructor argümanlarını çöz
                if (fieldAttribute.ConstructorArguments.Length == 3)
                {
                    var startBit = (int)fieldAttribute.ConstructorArguments[0].Value!;
                    var length = (int)fieldAttribute.ConstructorArguments[1].Value!;
                    var endian = fieldAttribute.ConstructorArguments[2].Value!;
                    
                    var enumIntValue = (int)endian;
                    var endianStringName = enumIntValue == 0 ? "Little" : "Big";
                    var endianValue = (Endianness)enumIntValue;
                    
                    
                    fields.Add(new PropertyInfo(
                        Name: member.Name,
                        Type: member.Type.ToDisplayString(), // Property'nin tipi (int, long vb.)
                        StartBit: startBit,
                        Length: length,
                        Endian: endianStringName
                    ));
                }
            }
        }

        // Hiç özellik bulunmazsa bile sınıfı döndür (IProtocol implementasyonu için)
        return new ClassInfo(
            Name: classSymbol.Name,
            Namespace: classSymbol.ContainingNamespace.ToDisplayString(),
            Accessibility: classSymbol.DeclaredAccessibility.ToString().ToLower(),
            Fields: fields
        );
    }
        private static void Execute(SourceProductionContext context, ClassInfo classInfo)
        {
            var sb = new StringBuilder();
            var extensionClassName = $"{classInfo.Name}Extensions";
            var fields = classInfo.Fields;
            sb.AppendLine($"// <auto-generated/>");
            sb.AppendLine($"using System;");
            sb.AppendLine($"using ProtocolFactory.Core.Math;");
            sb.AppendLine($"using System.Buffers.Binary;");

            sb.AppendLine($"namespace {classInfo.Namespace}");
            sb.AppendLine($"{{");
            
            sb.AppendLine($"    public static partial class {extensionClassName}");
            sb.AppendLine($"    {{");
            
            sb.AppendLine($"        /// <summary>");
            sb.AppendLine($"        /// Deserialization.");
            sb.AppendLine($"        /// </summary>");
            sb.AppendLine($"        public static void DeserializeInline(this {classInfo.Name} instance, ReadOnlySpan<byte> source)");
            sb.AppendLine($"        {{");

                foreach (var field in fields)
                {
                    if (field.Endian == "Big")
                    {
                        var startBit= field.StartBit;
                        var length = field.Length;
                        var byteStartIndex = startBit / 8;
                        var lsb=Calculation.Numerics.MsbToLsbBigEndian(startBit,length);
                        var byteEndIndex = lsb / 8;
                        var lengthAsByte = byteEndIndex - byteStartIndex + 1;
                        var mask = Numerics.MaskCalculation(startBit, length);
                        var shift = Numerics.ShiftAmount(startBit, length);
                        sb.AppendLine($"            var {field.Name}Result=ProtocolPrimitives.ReadInt32BigEndianPtr(source.Slice({byteStartIndex}, {lengthAsByte}));");
                        sb.AppendLine($"            {field.Name}Result &= 0x{mask:X};");
                        if (shift > 0)
                        {
                            sb.AppendLine($"            {field.Name}Result >>= {shift};");
                        }
                        sb.AppendLine($"            instance.{field.Name}=({field.Type}){field.Name}Result;");
                        
                    }
                    else
                    {
                        sb.AppendLine($"            instance.{field.Name}=0;");
                    }
                }
                
            
            
            
            
            sb.AppendLine($"        }}");

            sb.AppendLine($"    }}");
            sb.AppendLine($"}}");

            context.AddSource($"{classInfo.Name}SetterExtensions.g.cs", sb.ToString());
        }
    public record ClassInfo(string Name, string Namespace, string Accessibility, List<PropertyInfo> Fields);
    public record PropertyInfo(string Name, string Type, int StartBit, int Length, string Endian);
}



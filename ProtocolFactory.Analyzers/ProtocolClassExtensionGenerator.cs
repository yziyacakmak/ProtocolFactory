using System;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using ProtocolFactory.Core.Attributes;

namespace ProtocolFactory.Analyzers
{
    [Generator]
    public class ProtocolClassExtensionGenerator : IIncrementalGenerator
    {
        public void Initialize(IncrementalGeneratorInitializationContext context)
        {
            // 1. [Protocol] Özniteliği İle İşaretlenmiş Kısmi Sınıfları Bul
            var protocolClasses = context.SyntaxProvider
                .CreateSyntaxProvider(
                    // Predicate: Hızlı filtreleme: Attribute listesi olan Class Declaration'ları seç
                    predicate: static (s, _) => s is ClassDeclarationSyntax c && c.AttributeLists.Count > 0,

                    // Transform: Anlamsal model ile detaylı analiz yap
                    transform: static (ctx, cancellationToken) => GetProtocolClassInfo(ctx)
                )
                // Sadece uygun sınıfları (partial ve [Protocol] ile işaretli) filtrele
                .Where(static info => info is not null)
                .Select(static (info, _) => info!);
            // 2. Kaynak Kodu Üret
            context.RegisterSourceOutput(protocolClasses,
                static (spc, classInfo) => Execute(spc, classInfo));
        }

        private static ClassDeclarationInfo? GetProtocolClassInfo(GeneratorSyntaxContext context)
        {
            var classDeclaration = (ClassDeclarationSyntax)context.Node;
            var classSymbol = context.SemanticModel.GetDeclaredSymbol(classDeclaration) as INamedTypeSymbol;

            if (classSymbol is null ||
                !classDeclaration.Modifiers.Any(mod => mod.IsKind(SyntaxKind.PartialKeyword)))
            {
                return null;
            }

            // 1. [Protocol] özniteliği kontrolü (Önceki gibi)
            var hasProtocolAttribute = classSymbol.GetAttributes()
                .Any(attr => attr.AttributeClass?.Name == nameof(ProtocolAttribute));

            if (!hasProtocolAttribute)
            {
                return null;
            }

            // 2. İşaretlenmiş Özellikleri Topla
            

            // Hiç özellik bulunmazsa bile sınıfı döndür (IProtocol implementasyonu için)
            return new ClassDeclarationInfo(
                Name: classSymbol.Name,
                Namespace: classSymbol.ContainingNamespace.ToDisplayString(),
                Accessibility: classSymbol.DeclaredAccessibility.ToString().ToLower()
            );
        }

        private static void Execute(SourceProductionContext context, ClassDeclarationInfo classInfo)
        {
            var sb = new StringBuilder();
            var extensionClassName = $"{classInfo.Name}Extensions";

            sb.AppendLine($"// <auto-generated/>");
            sb.AppendLine($"using System;");
            sb.AppendLine($"using ProtocolFactory.Core.Contracts;");
            sb.AppendLine($"using ProtocolFactory.Core.Math;"); // Extension metodun bulunduğu namespace

            sb.AppendLine($"namespace {classInfo.Namespace}");
            sb.AppendLine($"{{");

            // Sınıfın kendisi ve üretilen struct'ın adını alarak extension metodu üret.

            sb.AppendLine($"    public static class {extensionClassName}");
            sb.AppendLine($"    {{");

            // Extension metot: ReadOnlySpan<byte> alıp sınıfı doldurur.

            // Not: Core'daki generic metot imzası: 
            // Serialize<T, TProtoValue>(ref T instance, ReadOnlySpan<byte> source)

            sb.AppendLine($"        /// <summary>");
            sb.AppendLine($"        /// Protokol sınıfını ham byte dizisinden yükler ve doldurur (Deserialization).");
            sb.AppendLine($"        /// Bu metot, Core kütüphanesindeki generic serileştiriciyi çağırır.");
            sb.AppendLine($"        /// </summary>");
            sb.AppendLine($"        public static void Deserialize(this {classInfo.Name} instance, ReadOnlySpan<byte> source)");
            sb.AppendLine($"        {{");

            // KRİTİK ÇAĞRI: Generic metodu çağır.
            // ProtocolClassExtensions.Serialize<T, TProtoValue>(ref instance, source)

            // ProtocolSerializerExtensions yerine ProtocolClassExtensions kullanıldı (önceki konuşmaya istinaden)
            sb.AppendLine($"            Deserialization.Deserialize<{classInfo.Name}, {classInfo.Name}Value>(instance, source);");
            sb.AppendLine($"        }}");

            sb.AppendLine($"    }}");
            sb.AppendLine($"}}");

            context.AddSource($"{classInfo.Name}Extensions.g.cs", sb.ToString());
        }

        private record ClassDeclarationInfo(string Name, string Namespace, string Accessibility);
    }
}